// server/controllers/paymentController.js
import Razorpay from '../config/razorpay.js'; // Imports the default export from server/config/razorpay.js
import Student from '../models/student.js'; // Imports the default export from server/models/Student.js
import StudentFeeDue from '../models/feedue.js'; // Imports the default export from server/models/StudentFeeDue.js
import Payment from '../models/payment.js'; // Imports the default export from server/models/Payment.js
import crypto from 'crypto'; // Imports the built-in Node.js 'crypto' module

// Helper function to generate a unique order ID for Razorpay
const generateUniqueOrderId = () => {
  return `order_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
};

/**
 * @desc Initiate an online payment (create Razorpay order)
 * @route POST /api/payments/initiate
 * @access Private (Student)
 */
export const initiateOnlinePayment = async (req, res) => {
  try {
    // studentId comes from the authenticated user (e.g., from your auth middleware: req.user.id)
    const studentId = req.user.id;
    // studentFeeDueId and amount come from the frontend request body
    const { studentFeeDueId, amount } = req.body;

    // --- Input Validation ---
    if (!studentId || !studentFeeDueId || !amount) {
      return res
        .status(400)
        .json({ message: 'Missing required fields: studentId, studentFeeDueId, amount.' });
    }
    const parsedAmount = parseFloat(amount);
    if (isNaN(parsedAmount) || parsedAmount <= 0) {
      return res.status(400).json({ message: 'Amount must be a positive number.' });
    }

    // --- Fetch and Validate Related Documents ---
    const student = await Student.findById(studentId);
    const studentFeeDue = await StudentFeeDue.findById(studentFeeDueId).populate('feeStructure'); // Populate feeStructure to get its name

    if (!student || !studentFeeDue) {
      return res.status(404).json({ message: 'Student or Fee Due record not found.' });
    }

    // IMPORTANT: Security Check - Ensure the student is trying to pay for their OWN fee obligation
    if (studentFeeDue.student.toString() !== studentId) {
      return res
        .status(403)
        .json({ message: 'Unauthorized: This fee does not belong to your account.' });
    }

    // IMPORTANT: Validate amount against outstanding balance
    if (parsedAmount > studentFeeDue.balance) {
      return res
        .status(400)
        .json({
          message: `Amount exceeds outstanding balance of ₹${studentFeeDue.balance.toFixed(2)}.`,
        });
    }

    // --- Create an Order with Razorpay ---
    const orderOptions = {
      amount: parsedAmount * 100, // Razorpay requires amount in paisa (e.g., ₹500 = 50000 paisa)
      currency: 'INR', // Your currency (e.g., 'INR', 'USD')
      receipt: generateUniqueOrderId(), // A unique ID generated by your system for this transaction
      payment_capture: 1, // Auto-capture payment after successful authorization
      notes: {
        // Custom notes that will be passed back in the webhook
        studentId: studentId.toString(),
        studentFeeDueId: studentFeeDueId.toString(),
        description: `Fee payment for ${studentFeeDue.feeStructure?.name || 'College Fees'}`,
      },
    };

    const razorpayOrder = await Razorpay.orders.create(orderOptions);

    // --- Save a temporary Payment record in your DB ---
    // This record's status is 'Initiated' and will be updated by the webhook
    const payment = new Payment({
      student: studentId,
      studentFeeDue: studentFeeDueId,
      amount: parsedAmount,
      paymentMethod: 'Online',
      gatewayOrderId: razorpayOrder.id, // Store Razorpay's generated order ID
      status: 'Initiated', // Initial status before payment confirmation
      gatewayResponse: razorpayOrder, // Store the full order object for debugging
    });
    await payment.save();

    // --- Send necessary data to Frontend for Razorpay Checkout ---
    res.status(200).json({
      message: 'Payment initiated successfully.',
      razorpayOrderId: razorpayOrder.id, // Razorpay's order ID
      amount: razorpayOrder.amount, // Amount in paisa
      currency: razorpayOrder.currency,
      keyId: process.env.RAZORPAY_KEY_ID, // Your Razorpay Key ID (public key)
      studentName: student.name,
      studentEmail: student.email,
      studentPhone: student.phone, // Ensure your Student model has a 'phone' field
      paymentId: payment._id, // Your internal Payment record ID
    });
  } catch (error) {
    console.error('Error initiating online payment:', error);
    res.status(500).json({ message: 'Failed to initiate payment.', error: error.message });
  }
};

/**
 * @desc Handle Razorpay Webhook Callbacks (CRITICAL for payment status updates)
 * @route POST /api/payments/webhook
 * @access Public (Razorpay's servers)
 */
export const handleRazorpayWebhook = async (req, res) => {
  // --- Webhook Signature Verification (Security) ---
  const shasum = crypto.createHmac('sha256', process.env.RAZORPAY_WEBHOOK_SECRET);
  shasum.update(JSON.stringify(req.body)); // Update Hmac with the raw request body (as string)
  const digest = shasum.digest('hex'); // Compute the digest

  // Compare the computed digest with the signature sent in the request header
  if (digest === req.headers['x-razorpay-signature']) {
    const event = req.body.event; // Type of event (e.g., 'payment.captured', 'payment.failed')
    const paymentData = req.body.payload.payment.entity; // The actual payment object from Razorpay

    console.log(`Received Razorpay webhook event: ${event}`);
    // console.log('Full Webhook Payload:', req.body); // Uncomment for detailed debugging if needed

    try {
      switch (event) {
        case 'payment.captured': // Payment was successful
          const gatewayPaymentId = paymentData.id; // Razorpay's unique payment ID
          const gatewayOrderId = paymentData.order_id; // Razorpay's order ID (matches your gatewayOrderId)

          // Find and update the Payment record that was 'Initiated' for this order
          const payment = await Payment.findOneAndUpdate(
            { gatewayOrderId: gatewayOrderId, status: 'Initiated' }, // Find the payment based on gatewayOrderId and current status
            {
              status: 'Success',
              transactionId: gatewayPaymentId, // Store Razorpay's payment ID
              paymentDate: new Date(paymentData.created_at * 1000), // Convert Unix timestamp to Date object
              gatewayResponse: { ...paymentData, ...paymentData.notes }, // Store relevant parts of gateway response
            },
            { new: true } // Return the updated document
          );

          if (!payment) {
            console.warn(
              `Payment record not found or already processed for gateway order ID: ${gatewayOrderId}.`
            );
            // This can happen if webhook is sent multiple times or already updated.
            return res
              .status(200)
              .json({ message: 'Payment record not found or already processed.' });
          }

          // Update the corresponding StudentFeeDue record (the outstanding fee)
          const studentFeeDue = await StudentFeeDue.findById(payment.studentFeeDue);

          if (studentFeeDue) {
            studentFeeDue.amountPaid += payment.amount; // Add the paid amount
            // Ensure the payment ID is only pushed once to prevent duplicates
            if (!studentFeeDue.payments.includes(payment._id)) {
              studentFeeDue.payments.push(payment._id); // Link this successful payment
            }
            await studentFeeDue.save(); // This will trigger the pre-save hook to update status and balance

            // Update the Student's overall payment history
            const student = await Student.findById(payment.student);
            if (student && !student.paymentHistory.includes(payment._id)) {
              student.paymentHistory.push(payment._id);
              await student.save();
            }

            console.log(
              `Payment captured for order ${gatewayOrderId}. Student Fee Due and Student records updated.`
            );
          } else {
            console.error(
              `CRITICAL: StudentFeeDue not found for payment ID: ${payment._id}. Data inconsistency!`
            );
            // This is a serious issue that requires manual review/correction
          }
          break;

        case 'payment.failed': // Payment failed
          const failedGatewayOrderId = paymentData.order_id;
          const failedPayment = await Payment.findOneAndUpdate(
            { gatewayOrderId: failedGatewayOrderId, status: 'Initiated' }, // Find the initiated payment
            {
              status: 'Failed',
              paymentDate: new Date(paymentData.created_at * 1000),
              gatewayResponse: { ...paymentData, ...paymentData.notes },
            },
            { new: true }
          );

          if (failedPayment) {
            console.log(
              `Payment failed for order ${failedGatewayOrderId}. Payment record status updated.`
            );
          } else {
            console.warn(
              `Failed payment record not found or already processed for gateway order ID: ${failedGatewayOrderId}.`
            );
          }
          break;

        // You can add more cases for other Razorpay events like 'refund.processed' if needed
        default:
          console.log(`Unhandled Razorpay event type: ${event}`);
      }
      res.status(200).json({ status: 'success' }); // Acknowledge receipt of webhook to Razorpay
    } catch (err) {
      console.error('Error processing Razorpay webhook:', err);
      // It's important to return a 200 OK even on internal errors to prevent Razorpay from retrying excessively
      res.status(500).json({ message: 'Error processing webhook internally.' });
    }
  } else {
    // If signature mismatch, it means the request is not from Razorpay or secret is wrong
    console.warn(
      'Razorpay webhook signature mismatch! Possible malicious request or misconfiguration.'
    );
    res.status(400).json({ status: 'error', message: 'Signature mismatch' });
  }
};
